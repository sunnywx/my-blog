{"url":"/blog/2022-10/reduce-gitalk-bundle","date":"2022-10-19","tags":["webpack","refine"],"content":"\n## lazy load\n评论插件gitalk的react组件体积比较大 (~700K), 直接静态import会导致某个chunk的体积很大。\n尝试使用lazy, Suspense来主动分包。\n\n```tsx\nimport \"gitalk/dist/gitalk.css\"\nconst Gitalk=lazy(()=> import(\"gitalk/dist/gitalk-component\"))\n\n<Suspense fallback={<div>Loading gitalk..</div>}>\n  {typeof window !== \"undefined\" && (\n    <Gitalk options={gitalkOptions} />\n  )}\n</Suspense>\n```\n这样虽然可以手动将gitalk分包，但是对于整体的bundle大小依然没有减少。\n与其减小某个包，不如完全不要这个包。于是考虑不使用react组件，用script从CDN加载，这样可以彻底消除gitalk的bundle。\n\n## off load\n\n首先在父组件内用`Helmet`动态加载gitalk对应的css, js\n\n```tsx\n<Helmet>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\" />\n  <script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\" />\n</Helmet>\n```\n\n由于不确定gitalk对应的js脚本何时会将构造函数挂载到window对象，需要用timer来监听\n\n```tsx\nuseEffect(() => {\n  const gitalkOptions = {...}\n\n  let tm: number = setInterval(() => {\n    if (window.Gitalk) {\n      const gitalk = new window.Gitalk(gitalkOptions)\n      gitalk.render('gitalk-container')\n\n      clearInterval(tm)\n    }\n  }, 100)\n\n  return () => {\n    clearInterval(tm)\n    tm = null\n  }\n}, [blogUrl])\n```\n"}