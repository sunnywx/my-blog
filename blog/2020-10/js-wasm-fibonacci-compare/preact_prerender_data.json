{"url":"/blog/2020-10/js-wasm-fibonacci-compare","date":"2020-10-14","tags":[],"content":"\n![](/assets/images/js-wasm-bench.png)\n\n## Rust 环境准备\n\n我准备用`rust`来编译到`wasm`，当然你也可以用 `c/c++`, `go`, `assemblyScript/typescript` 来 compile 到 wasm.\n\n首选准备 rust 环境，安装`rustup`\n\n```shell script\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n\nexport PATH=\"$HOME/.cargo/bin:$PATH\"\n\n# 检查rustc 安装成功\nrustc --version\n# 检查 cargo 安装成功\ncargo --version\n\n# 安装wasm的编译目标\nrustup target add wasm32-unknown-unknown\n\n```\n\n## 创建 rust lib，编译到 wasm\n\n使用 cargo(rust 的包管理器和 build 工具) 创建一个 type 为 library 的项目\n\n```shell script\ncargo new begin_wasm --lib\n```\n\ncargo 初始化的目录结构是\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n`src/lib.rs`就是要编译到 wasm 的 rust 文件，先加入斐波那契数的函数，稍后编译到 wasm 里。\n\n```rust\n#[no_mangle]\npub fn fib(n: u32) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n```\n\n编译到 wasm\n\n```shell script\ncargo build --target wasm32-unknown-unknown\n```\n\n这时在项目目录下会多出一个`target`目录，默认 cargo 是在 debug 模式下编译，wasm 文件体积会稍大点。\n生成的 wasm 文件在 `target/wasm32-unknwon-unknown/debug/begin_wasm.wasm`\n\n## JS 端创建测试页面\n\n```shell script\ntouch index.html\n```\n\nindex.html 的内容如下\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>rust wasm</title>\n  </head>\n  <body>\n    <h2>Fibnacci benchmark: JS vs Wasm</h2>\n\n    <div id=\"result\">\n      <div id=\"fib-js\"></div>\n\n      <div id=\"fib-wasm\"></div>\n    </div>\n\n    <script>\n      const wasm_file = \"target/wasm32-unknown-unknown/debug/begin_wasm.wasm\"\n\n      const fib = n => {\n        if (n === 0 || n === 1) {\n          return 1\n        }\n        return fib(n - 1) + fib(n - 2)\n      }\n\n      const t1 = Date.now()\n      const res_js = fib(40)\n      const t2 = Date.now()\n\n      document.getElementById(\n        \"fib-js\"\n      ).innerHTML = `==JS==: Calc fib(40), time=${(t2 - t1) /\n        1000}s, res=${res_js}`\n\n      const memory = new WebAssembly.Memory({ initial: 10, maximum: 100 }) // alloc wasm memory size\n\n      WebAssembly.instantiateStreaming(fetch(wasm_file), {\n        js: { mem: memory },\n      }).then(mod => {\n        const wasm_exports = mod.instance.exports\n\n        const t1 = Date.now()\n        const res_wasm = wasm_exports.fib(40)\n        const t2 = Date.now()\n\n        document.getElementById(\n          \"fib-wasm\"\n        ).innerHTML = `==WASM==: Calc fib(40), time=${(t2 - t1) /\n          1000}s, res=${res_wasm}`\n      })\n    </script>\n  </body>\n  <html></html>\n</html>\n```\n\n## 开启本地 http server\n\n本地测试的话，可以有很多方式开启 http server，你可以用 cargo 安装 rust 版的 http server\n\n```shell script\ncargo install https\n\nhttp  # 启动http server\n```\n\n也可以 nodejs 的 npm 安装 http server\n\n```shell script\nnpm i http-server\n\nhttp-server .\n```\n\n然后打开浏览器(比如我的 chrome)，进到测试页面, benchmark 对比：\n\n![](/assets/images/js-wasm-fib.jpg)\n\n## 总结\n\n以上是对比 js 和 wasm 计算 斐波那契数列的第 42 项，也是很大的一个数了，js 用的时间竟然比 wasm 少?（什么原因呢，各位观众可以在评论区留言发表看法:-p）\nwasm 的性能和 c/c++差不多，这里应该是 chrome v8 引擎在处理 js 的计算时做了编译优化，让 js 计算 fib(42) 甚至比 wasm 还快。\n\n当然局部的 benchmark 对比看不出什么优势，在重计算的项目(cpu 密集型)中，wasm 的优势就会比 js 明显。\n\n未来 WASM 会和 JS 优势互补，二者不是对立的关系，wasm 也不会取代 js，wasm 只是增强了 js，就像 typescript 只是给 js 加了类型和静态分析。\n\n很愉快的 WASM 之旅，happy coding :)\n"}