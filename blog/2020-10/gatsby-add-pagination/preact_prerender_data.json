{"url":"/blog/2020-10/gatsby-add-pagination","date":"2020-10-13","tags":["gatsby","graphql"],"content":"\n## gatsby 下分页的难点\n\ngatsby 生成的都是静态网页，数据是通过 graphql 聚合的，这里查询数据不像传统的关系型数据库那样\n直接通过`limit`, `offset`来控制分页数据。gatsby 的数据源可能是每个 markdown 经过 nodejs 转换后的纯 json，\n再通过 graphql 的接口来查本地的 json 数据，也就是页面加载到浏览器后，不能像传统的发起 ajax 请求，因为没有一个接收分页参数的后端。\n\n所以只能在每个页面生成之前就提前拿到全局的分页数据，比如 总页数，当前页码，再注入页面，让页面在浏览器加载就可以使用这些数据。\n\n考虑到 gatsby 生成页面的逻辑是通过在 `gatsby-node.js`里调用 nodejs 的接口，最典型的就是 `createPages`, `createPage`。\n\n## gatsby-node 生成分页列表\n\n```javascript\nexports.createPages = async ({ graphql, actions }) => {\n  const { createPage } = actions\n\n  const result = await graphql(\n    `\n      {\n        allMarkdownRemark(\n          sort: { fields: [frontmatter___date], order: DESC }\n          limit: 1000\n        ) {\n          edges {\n            node {\n              fields {\n                slug\n              }\n              frontmatter {\n                title\n              }\n            }\n          }\n        }\n      }\n    `\n  )\n\n  if (result.errors) {\n    throw result.errors\n  }\n\n  const posts = result.data.allMarkdownRemark.edges\n  const postsPerPage = 10\n  const numPages = Math.ceil(posts.length / postsPerPage)\n\n  // save numPages to global data\n  fs.writeFileSync(\n    path.resolve(__dirname, \"src/data/num-pages.js\"),\n    `export default ${numPages}`\n  )\n\n  // create paginated page\n  Array.from({ length: numPages }).forEach((_, i) => {\n    createPage({\n      path: i === 0 ? `/blog` : `/blog/${i + 1}`,\n      component: path.resolve(\"./src/templates/blog-list.js\"),\n      context: {\n        limit: postsPerPage,\n        skip: i * postsPerPage,\n        numPages,\n        currentPage: i + 1,\n      },\n    })\n  })\n\n  // create each post\n  posts.forEach((post, index) => {\n    const previous = index === posts.length - 1 ? null : posts[index + 1].node\n    const next = index === 0 ? null : posts[index - 1].node\n\n    createPage({\n      path: `/blog${post.node.fields.slug}`,\n      component: path.resolve(`./src/templates/blog-post.js`),\n      context: {\n        slug: post.node.fields.slug,\n        previous,\n        next,\n      },\n    })\n  })\n}\n```\n\n上面是完整的在 nodejs 端生成单独分页的列表页和每个子页面的逻辑。\n\n这里涉及两个模板，一个是每个分页对应的列表页（对应 `src/templates/blog-list.js`），一个是每个 blog 的详情页(对应 `src/templates/blog-post.js`).\n\n`templates/blog-list`的代码如下\n\n```js\nimport React from \"react\"\nimport { graphql } from \"gatsby\"\n\nimport Layout from \"components/layout\"\nimport ListItem from \"components/list-item\"\nimport Pagination from \"components/pagination\"\n\nexport default class BlogList extends React.Component {\n  render() {\n    const { data, pageContext } = this.props\n    const siteTitle = data.site.siteMetadata.title\n    const posts = data.allMarkdownRemark.edges\n    const { currentPage, numPages } = pageContext\n\n    return (\n      <Layout location={this.props.location} title={siteTitle}>\n        {posts.map(({ node }) => (\n          <ListItem node={node} key={node.fields.slug} />\n        ))}\n\n        <Pagination numPages={numPages} currentPage={currentPage} />\n      </Layout>\n    )\n  }\n}\n\nexport const blogListQuery = graphql`\n  query blogListQuery($skip: Int!, $limit: Int!) {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n\n    allMarkdownRemark(\n      sort: { fields: [frontmatter___date], order: DESC }\n      limit: $limit\n      skip: $skip\n    ) {\n      edges {\n        node {\n          excerpt\n          fields {\n            slug\n          }\n          frontmatter {\n            date\n            title\n            description\n            tags\n          }\n        }\n      }\n    }\n  }\n`\n```\n\n最终的效果如图：\n![](/assets/images/gatsby-pagination.jpg)\n"}