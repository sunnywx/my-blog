[
  {
    "url": "/",
    "title": "Home"
  },
  {
    "url": "/about",
    "title": "About me"
  },
  {
    "url": "/blog/2022-10/reduce-gitalk-bundle",
    "title": "gitalk打包优化",
    "date": "2022-10-19",
    "tags": [
      "webpack"
    ],
    "content": "\n## lazy load\n评论插件gitalk的react组件体积比较大 (~700K), 直接静态import会导致某个chunk的体积很大。\n尝试使用lazy, Suspense来主动分包。\n\n```tsx\nimport \"gitalk/dist/gitalk.css\"\nconst Gitalk=lazy(()=> import(\"gitalk/dist/gitalk-component\"))\n\n<Suspense fallback={<div>Loading gitalk..</div>}>\n  {typeof window !== \"undefined\" && (\n    <Gitalk options={gitalkOptions} />\n  )}\n</Suspense>\n```\n这样虽然可以手动将gitalk分包，但是对于整体的bundle大小依然没有减少。\n与其减小某个包，不如完全不要这个包。于是考虑不使用react组件，用script从CDN加载，这样可以彻底消除gitalk的bundle。\n\n## off load\n\n首先在父组件内用`Helmet`动态加载gitalk对应的css, js\n\n```tsx\n<Helmet>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\" />\n  <script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\" />\n</Helmet>\n```\n\n由于不确定gitalk对应的js脚本何时会将构造函数挂载到window对象，需要用timer来监听\n\n```tsx\nlet rendered = false\n\nuseEffect(() => {\n  const gitalkOptions = {...}\n\n  let tm: number = setInterval(() => {\n    if (window.Gitalk && !rendered) {\n      rendered = true\n      const gitalk = new window.Gitalk(gitalkOptions)\n      gitalk.render('gitalk-container')\n\n      clearInterval(tm)\n    }\n  }, 200)\n\n  return () => {\n    clearInterval(tm)\n    tm = null\n  }\n}, [blogUrl])\n```\n"
  },
  {
    "url": "/blog/2022-10/ways-to-run-jsx-in-node",
    "title": "ways to run jsx in nodejs",
    "date": "2022-10-17",
    "tags": [
      "react",
      "node"
    ],
    "content": "\n如何在nodejs repl下运行下面的代码：\n\n```js\n// ssr.js\n\n/** @jsx h */\nimport {render} from 'preact-render-to-string'\nimport {h} from 'preact'\n\nconst App=<div className='app'>full content </div>\n\nconsole.log(render(App))\n```\n\n## babel-node\n\n安装依赖\n```shell\nyarn add --dev @babel/core @babel/node @babel/preset-env @babel/preset-react @babel/plugin-transform-react-jsx\nbabel-node ssr.js\n```\n\n## ts-node\n```shell\nyarn add --dev ts-node\nts-node --esm ssr.js\n```"
  },
  {
    "url": "/blog/2022-10/react-different-render-ways",
    "title": "react different render ways",
    "date": "2022-10-13",
    "tags": [
      "react"
    ],
    "content": "\n## render\n\n## hydrate\n\n## pre-render\n\n## ssr\n\n## ssg (static export)"
  },
  {
    "url": "/blog/2021-03/feynman-learning-method",
    "title": "feynman learning method",
    "date": "2021-03-20",
    "tags": [
      "learning"
    ],
    "content": "\n![feynman tech](/assets/images/feynman-tech.webp)\n\n\n\n\n\n"
  },
  {
    "url": "/blog/2020-10/js-wasm-fibonacci-compare",
    "title": "javascript vs webassembly fibonacci benchmark",
    "date": "2020-10-14",
    "tags": [
      "wasm",
      "rust"
    ],
    "content": "\n![](/assets/images/js-wasm-bench.png)\n\n## Rust 环境准备\n\n我准备用`rust`来编译到`wasm`，当然你也可以用 `c/c++`, `go`, `assemblyScript/typescript` 来 compile 到 wasm.\n\n首选准备 rust 环境，安装`rustup`\n\n```shell script\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n\nexport PATH=\"$HOME/.cargo/bin:$PATH\"\n\n# 检查rustc 安装成功\nrustc --version\n# 检查 cargo 安装成功\ncargo --version\n\n# 安装wasm的编译目标\nrustup target add wasm32-unknown-unknown\n\n```\n\n## 创建 rust lib，编译到 wasm\n\n使用 cargo(rust 的包管理器和 build 工具) 创建一个 type 为 library 的项目\n\n```shell script\ncargo new begin_wasm --lib\n```\n\ncargo 初始化的目录结构是\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n`src/lib.rs`就是要编译到 wasm 的 rust 文件，先加入斐波那契数的函数，稍后编译到 wasm 里。\n\n```rust\n#[no_mangle]\npub fn fib(n: u32) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n```\n\n编译到 wasm\n\n```shell script\ncargo build --target wasm32-unknown-unknown\n```\n\n这时在项目目录下会多出一个`target`目录，默认 cargo 是在 debug 模式下编译，wasm 文件体积会稍大点。\n生成的 wasm 文件在 `target/wasm32-unknwon-unknown/debug/begin_wasm.wasm`\n\n## JS 端创建测试页面\n\n```shell script\ntouch index.html\n```\n\nindex.html 的内容如下\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>rust wasm</title>\n  </head>\n  <body>\n    <h2>Fibnacci benchmark: JS vs Wasm</h2>\n\n    <div id=\"result\">\n      <div id=\"fib-js\"></div>\n\n      <div id=\"fib-wasm\"></div>\n    </div>\n\n    <script>\n      const wasm_file = \"target/wasm32-unknown-unknown/debug/begin_wasm.wasm\"\n\n      const fib = n => {\n        if (n === 0 || n === 1) {\n          return 1\n        }\n        return fib(n - 1) + fib(n - 2)\n      }\n\n      const t1 = Date.now()\n      const res_js = fib(40)\n      const t2 = Date.now()\n\n      document.getElementById(\n        \"fib-js\"\n      ).innerHTML = `==JS==: Calc fib(40), time=${(t2 - t1) /\n        1000}s, res=${res_js}`\n\n      const memory = new WebAssembly.Memory({ initial: 10, maximum: 100 }) // alloc wasm memory size\n\n      WebAssembly.instantiateStreaming(fetch(wasm_file), {\n        js: { mem: memory },\n      }).then(mod => {\n        const wasm_exports = mod.instance.exports\n\n        const t1 = Date.now()\n        const res_wasm = wasm_exports.fib(40)\n        const t2 = Date.now()\n\n        document.getElementById(\n          \"fib-wasm\"\n        ).innerHTML = `==WASM==: Calc fib(40), time=${(t2 - t1) /\n          1000}s, res=${res_wasm}`\n      })\n    </script>\n  </body>\n  <html></html>\n</html>\n```\n\n## 开启本地 http server\n\n本地测试的话，可以有很多方式开启 http server，你可以用 cargo 安装 rust 版的 http server\n\n```shell script\ncargo install https\n\nhttp  # 启动http server\n```\n\n也可以 nodejs 的 npm 安装 http server\n\n```shell script\nnpm i http-server\n\nhttp-server .\n```\n\n然后打开浏览器(比如我的 chrome)，进到测试页面, benchmark 对比：\n\n![](/assets/images/js-wasm-fib.jpg)\n\n## 总结\n\n以上是对比 js 和 wasm 计算 斐波那契数列的第 42 项，也是很大的一个数了，js 用的时间竟然比 wasm 少?（什么原因呢，各位观众可以在评论区留言发表看法:-p）\nwasm 的性能和 c/c++差不多，这里应该是 chrome v8 引擎在处理 js 的计算时做了编译优化，让 js 计算 fib(42) 甚至比 wasm 还快。\n\n当然局部的 benchmark 对比看不出什么优势，在重计算的项目(cpu 密集型)中，wasm 的优势就会比 js 明显。\n\n未来 WASM 会和 JS 优势互补，二者不是对立的关系，wasm 也不会取代 js，wasm 只是增强了 js，就像 typescript 只是给 js 加了类型和静态分析。\n\n很愉快的 WASM 之旅，happy coding :)\n"
  },
  {
    "url": "/blog/2020-10/styled-components-add-media-query",
    "title": "styled-components add media query",
    "date": "2020-10-14",
    "tags": [
      "css"
    ],
    "content": "\nMedia query 在`styled-components`下的使用，和普通 css 下是一样的，只是 styled-components 支持 SCSS 的语法\n，另外可以在 es6 的模板字符串(tagged template)下有独特的写法。\n\n![](/assets/images/styled-comp-scss.jpeg)\n\n## 传统的写法\n\n```\n#wrapper {\n  display: flex;\n  flex-direction: row;\n  @media (max-width: 768px) {\n    flex-direction: column;\n  }\n}\n\n```\n\n## styled-components 下的写法\n\n```js\nimport styled from \"styled-components\"\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  @media (max-width: 768px) {\n    flex-direction: column;\n  }\n`\n```\n\n## styled-component 下的 scss 写法\n\n```js\nconst Article = styled.div`\n  > h3 {\n    margin-bottom: 1rem;\n    > a {\n      text-decoration: none;\n    }\n  }\n  \n  .snapshots{\n    display: flex;\n    \n    > img {\n      @media (min-width: 1024px} {\n        width: 30%;        \n      }\n    }\n  }\n`\n```\n\n`styled.div` 后面接的是 模板字符串，可以插值(interpolate)，所以可以把不同分辨率的配置抽出来：\n\n```js\n// config/device-size.js\n\nexport const size = {\n  mobile: \"425px\",\n  tablet: \"768px\",\n  desktop: \"1024px\",\n}\n\nexport const device = {\n  mobile: `(max-width: ${size.mobile})`,\n  tablet: `(min-width: ${size.tablet}) and (max-width: ${size.desktop})`,\n  desktop: `(min-width: ${size.desktop})`,\n}\n```\n\n最终的 styled-components media query 写法\n\n```js\nconst Article = styled(Card)`\n  > h3 {\n    margin-bottom: 1rem;\n    > a {\n      text-decoration: none;\n    }\n  }\n\n  .snapshots {\n    display: flex;\n\n    > img {\n      @media ${device.desktop} {\n        width: 30%;\n      }\n    }\n  }\n`\n```\n"
  },
  {
    "url": "/blog/2020-10/gatsby-add-pagination",
    "title": "gatsby page add pagination",
    "date": "2020-10-13",
    "tags": [
      "gatsby",
      "graphql"
    ],
    "content": "\n## gatsby 下分页的难点\n\ngatsby 生成的都是静态网页，数据是通过 graphql 聚合的，这里查询数据不像传统的关系型数据库那样\n直接通过`limit`, `offset`来控制分页数据。gatsby 的数据源可能是每个 markdown 经过 nodejs 转换后的纯 json，\n再通过 graphql 的接口来查本地的 json 数据，也就是页面加载到浏览器后，不能像传统的发起 ajax 请求，因为没有一个接收分页参数的后端。\n\n所以只能在每个页面生成之前就提前拿到全局的分页数据，比如 总页数，当前页码，再注入页面，让页面在浏览器加载就可以使用这些数据。\n\n考虑到 gatsby 生成页面的逻辑是通过在 `gatsby-node.js`里调用 nodejs 的接口，最典型的就是 `createPages`, `createPage`。\n\n## gatsby-node 生成分页列表\n\n```javascript\nexports.createPages = async ({ graphql, actions }) => {\n  const { createPage } = actions\n\n  const result = await graphql(\n    `\n      {\n        allMarkdownRemark(\n          sort: { fields: [frontmatter___date], order: DESC }\n          limit: 1000\n        ) {\n          edges {\n            node {\n              fields {\n                slug\n              }\n              frontmatter {\n                title\n              }\n            }\n          }\n        }\n      }\n    `\n  )\n\n  if (result.errors) {\n    throw result.errors\n  }\n\n  const posts = result.data.allMarkdownRemark.edges\n  const postsPerPage = 10\n  const numPages = Math.ceil(posts.length / postsPerPage)\n\n  // save numPages to global data\n  fs.writeFileSync(\n    path.resolve(__dirname, \"src/data/num-pages.js\"),\n    `export default ${numPages}`\n  )\n\n  // create paginated page\n  Array.from({ length: numPages }).forEach((_, i) => {\n    createPage({\n      path: i === 0 ? `/blog` : `/blog/${i + 1}`,\n      component: path.resolve(\"./src/templates/blog-list.js\"),\n      context: {\n        limit: postsPerPage,\n        skip: i * postsPerPage,\n        numPages,\n        currentPage: i + 1,\n      },\n    })\n  })\n\n  // create each post\n  posts.forEach((post, index) => {\n    const previous = index === posts.length - 1 ? null : posts[index + 1].node\n    const next = index === 0 ? null : posts[index - 1].node\n\n    createPage({\n      path: `/blog${post.node.fields.slug}`,\n      component: path.resolve(`./src/templates/blog-post.js`),\n      context: {\n        slug: post.node.fields.slug,\n        previous,\n        next,\n      },\n    })\n  })\n}\n```\n\n上面是完整的在 nodejs 端生成单独分页的列表页和每个子页面的逻辑。\n\n这里涉及两个模板，一个是每个分页对应的列表页（对应 `src/templates/blog-list.js`），一个是每个 blog 的详情页(对应 `src/templates/blog-post.js`).\n\n`templates/blog-list`的代码如下\n\n```js\nimport React from \"react\"\nimport { graphql } from \"gatsby\"\n\nimport Layout from \"components/layout\"\nimport ListItem from \"components/list-item\"\nimport Pagination from \"components/pagination\"\n\nexport default class BlogList extends React.Component {\n  render() {\n    const { data, pageContext } = this.props\n    const siteTitle = data.site.siteMetadata.title\n    const posts = data.allMarkdownRemark.edges\n    const { currentPage, numPages } = pageContext\n\n    return (\n      <Layout location={this.props.location} title={siteTitle}>\n        {posts.map(({ node }) => (\n          <ListItem node={node} key={node.fields.slug} />\n        ))}\n\n        <Pagination numPages={numPages} currentPage={currentPage} />\n      </Layout>\n    )\n  }\n}\n\nexport const blogListQuery = graphql`\n  query blogListQuery($skip: Int!, $limit: Int!) {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n\n    allMarkdownRemark(\n      sort: { fields: [frontmatter___date], order: DESC }\n      limit: $limit\n      skip: $skip\n    ) {\n      edges {\n        node {\n          excerpt\n          fields {\n            slug\n          }\n          frontmatter {\n            date\n            title\n            description\n            tags\n          }\n        }\n      }\n    }\n  }\n`\n```\n\n最终的效果如图：\n![](/assets/images/gatsby-pagination.jpg)\n"
  },
  {
    "url": "/blog/2020-04/be-a-productive-team-member",
    "title": "Be a productive team member",
    "date": "2020-04-08",
    "tags": [
      "jobs"
    ],
    "content": "\n> 天赋可以让你赢得比赛，但是团队合作与智慧可以让你赢得总冠军 -- michael jordan\n\n## 了解实情\n\n出色的团队合作者了解团队需要做什么以及为什么要这么做。他们知道自己的技能和品性对集体的努力有何助益。 简单地听命于人会让人迅速产生愤恨情绪并与团队格格不入。将自己当作团队一员时，您知道自己的位置和身处该位置的原因，也知道如何支持与改善他人的工作。\n\n## 支持队友\n\n当工作进展顺利时，应该首先考虑对队友的工作给予认可和鼓励。如果遇到困难，应在可以提供帮助的情况下向队友伸出援助之手。\n\n## 提出建设性的批评\n\n因为您了解集体目标，也明白您和队友如何才能为实现这些目标贡献自己的力量，所以在遇到障碍时，您可以提供建议和帮助。但是一定要小心。只有在感受到您的真诚，而且您提出的是建设性、有帮助并适合于实现共同目标的批评时，受到批评的人才会报以良好的反应。所以，您要真诚和诚恳地提出批评。真正擅长团队合作的人不会靠暗害同事来让自己“得分”。\n\n## 处理冲突\n\n在职场中，想要完全避免冲突几乎不可能。无论如何，人与人之间都会发生冲突，尤其是当你们都在紧张的时限或一定的压力下工作时。您要记住，好团队有一样重要的美德，那就是它能将各种技能和不同性格凝聚成合力。如果确实出现了意见分歧，擅长团队合作的人会将解决办法和想法拿到桌面上，并且能够接受批评，只要这些批评像他们提出的批评那样具有建设性。无论您处于职业生涯的哪个阶段，也不管您的抱负是什么，冲突管理都是一项真正重要的技能和核心领导能力。\n\n## 清楚自己的界限\n\n无论是处理冲突还是设法达到他人的期望，知道自己的限度和（引申开来）自己的界限在哪里才是自信的表现。致力于完成团队项目时，这种投入也要切合实际。过分投入或急于取悦他人都会导致压力、怨恨和耽误集体项目成功的障碍。知道何时应该说“不”或者如何与团队领导或同事谈判以便在合理的期限内顺利完成工作非常重要。\n\n想要变得擅长团队协作有时并不容易，需要经过时间和经验的磨炼。\n\n但是，坚持下去并保持本心，不改初衷，同时始终尊重别人，就一定能成为最终获胜团队的一员。\n"
  },
  {
    "url": "/blog/2020-04/django-webpack-hot-reload",
    "title": "django webpack hot reload",
    "date": "2020-04-07",
    "tags": [
      "webpack"
    ],
    "content": "\n## 1. 设置后端环境\n\n```shell\n# init python virtrual env\npip install virtualenv\nvirtualenv venv\nsource ./venv/bin/activate\n\npip install django-webpack-loader\n```\n\n## 2. 设置 django 的 settings.py\n\n```shell\nWEBPACK_LOADER = {\n    'DEFAULT': {\n        'CACHE': not DEBUG,\n        'BUNDLE_DIR_NAME': 'dist/', # must end with slash\n        'STATS_FILE': os.path.join(BASE_DIR, 'static/dist/webpack-stats.json'),\n        'POLL_INTERVAL': 0.1,\n        'TIMEOUT': None,\n        'IGNORE': ['.+\\.hot-update.js', '.+\\.map']\n    }\n}\n\n```\n\n## 3. 设置 webpack (开发环境)\n\n```shell\nconst path = require('path')\nconst webpackNotifier = require('webpack-notifier')\nconst ManifestPlugin = require('webpack-manifest-plugin')\nconst BundleTracker = require('webpack-bundle-tracker')\n\nconst devServerPort = process.env.DEV_SERVER_PORT || 9000\n\nmodule.exports = {\n  mode: 'development',\n  devtool: 'cheap-module-eval-source-map',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'static/dist'),\n    filename: '[name].js',\n    chunkFilename: '[name].chunk.js',\n\n    // if you want hmr, point to webpack-dev-server path, not django static file\n    publicPath: `http://localhost:${devServerPort}/static/dist/`\n  },\n  devServer: {\n    contentBase: path.resolve(__dirname, 'static/dist'),\n    compress: true,\n    port: process.env.DEV_SERVER_PORT || 9000,\n    headers: {\n      'Access-Control-Allow-Origin': '*'\n    },\n    historyApiFallback: true,\n\n    // HMR\n    hotOnly: true,\n    inline: true,\n    clientLogLevel: 'warn'\n  },\n  plugins: [\n    new ManifestPlugin({\n      publicPath: 'static/dist/'\n    }),\n    new BundleTracker({\n      filename: './static/dist/webpack-stats.json'\n    })\n  ]\n}\n\n```\n\n## 4. django 模板\n\n```html\n{% load custom_tags %} {% load render_bundle from webpack_loader %}\n<!DOCTYPE html>\n<html lang=\"{{ site.lang|default:'zh-cn' }}\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n\n    {% block styles %} {% if is_prod %}\n    <link rel=\"stylesheet\" href=\"{{ 'styles.css' | get_manifest_asset }}\" />\n    {% endif %} {% endblock %}\n  </head>\n  <body>\n    {% block content %}\n    <div id=\"app\"></div>\n    {% endblock %} {% block scripts %} {% if is_prod %}\n    <script src=\"{{ 'styles.js' | get_manifest_asset }}\"></script>\n    <script src=\"{{ 'main.js' | get_manifest_asset }}\"></script>\n    {% else %} {% render_bundle 'main' %} {% endif %} {% endblock %}\n  </body>\n</html>\n```\n\n### 实际项目中的演示：\n\n![django webpack热加载](/assets/images/django-webpack-hot-reload.jpg)\n"
  },
  {
    "url": "/blog/2020-04/mac-catalina-install-libvips",
    "title": "Mac 10.15 安装 libvips",
    "date": "2020-04-06",
    "tags": [
      "mac"
    ],
    "content": "\ngatsby 的图片处理库`sharp`很方便，但是 sharp 依赖 c++编写的 `libvips`。\n当 Mac 升级到 catalina(10.15), `brew`安装时一直失败，当尝试源码编译，会出现`tiff`依赖的错误。\n还有`zlib`在 catalina 默认的 `pkg-config`的配置`zlib.pc`错误。针对我遇到的情形，解决方式如下。\n\n```\n// 从github 下载最新的gz包，vips-8.9.1.tar.gz\n\ntar xf vips-8.9.1.tar.gz\ncd vips-8.9.1\n\n./configuration --with-jpeg --with-png --without-tiff\n\nmake\n\nsudo make install\n\nrm -rf node_modules\n\nnpm i --unsafe-perm --build-from-source --verbose\n\n```\n\n改进之处\n\n- 在 markdown 内引入 png 图片，gatsby 有时会编译出错 (可能是 libvips 编译的参数不对， 或者`gatsby-plugin-sharp`的 bug)\n- `brew info vips` 显示的 vips 版本始终是 8.8.x，尝试升级 brew，拉取`brew/versions`仓库也报错，可能是`brew/core`的 bug\n- 等 brew 官方发新版，最简单的就是通过`brew install vips`安装 libvips\n\n参考文档\n\n- [https://sharp.pixelplumbing.com/install](https://sharp.pixelplumbing.com/install)\n- [https://libvips.github.io/libvips/install.html#building-libvips-from-a-source-tarball](https://libvips.github.io/libvips/install.html#building-libvips-from-a-source-tarball)\n- [https://github.com/gatsbyjs/gatsby/issues/21032](https://github.com/gatsbyjs/gatsby/issues/21032)\n"
  },
  {
    "url": "/blog/2019-10/google-advanced-operators",
    "title": "google search operator",
    "date": "2019-10-26",
    "tags": [
      "google",
      "tips"
    ],
    "content": "\n## allinanchor:\n\nIf you start your query with allinanchor:, Google restricts results to pages containing all query terms you specify in the anchor text on links to the page. For example, [ allinanchor: best museums sydney ] will return only pages in which the anchor text on links to the pages contain the words “best,” “museums,” and “sydney.”\n\nAnchor text is the text on a page that is linked to another web page or a different place on the current page. When you click on anchor text, you will be taken to the page or place on the page to which it is linked. When using allinanchor: in your query, do not include any other search operators. The functionality of allinanchor: is also available through the Advanced Web Search page, under Occurrences.\n\n## allintext:\n\nIf you start your query with allintext:, Google restricts results to those containing all the query terms you specify in the text of the page. For example, [ allintext: travel packing list ] will return only pages in which the words “travel,” “packing,” and “list” appear in the text of the page. This functionality can also be obtained through the Advanced Web Search page, under Occurrences.\n\n## allintitle:\n\nIf you start your query with allintitle:, Google restricts results to those containing all the query terms you specify in the title. For example, [ allintitle: detect plagiarism ] will return only documents that contain the words “detect” and “plagiarism” in the title. This functionality can also be obtained through the Advanced Web Search page, under Occurrences.\n\nThe title of a webpage is usually displayed at the top of the browser window and in the first line of Google’s search results for a page. The author of a website specifies the title of a page with the HTML TITLE element. There’s only one title in a webpage. When using allintitle: in your query, do not include any other search operators. The functionality of allintitle: is also available through the Advanced Web Search page, under Occurrences.\n\nIn Image Search, the operator allintitle: will return images in files whose names contain the terms that you specify.\n\nIn Google News, the operator allintitle: will return articles whose titles include the terms you specify.\n\n## allinurl:\n\nIf you start your query with allinurl:, Google restricts results to those containing all the query terms you specify in the URL. For example, [ allinurl: google faq ] will return only documents that contain the words “google” and “faq” in the URL, such as “www.google.com/help/faq.html”. This functionality can also be obtained through the Advanced Web Search page, under Occurrences.\n\nIn URLs, words are often run together. They need not be run together when you’re using allinurl:.\n\nIn Google News, the operator allinurl: will return articles whose titles include the terms you specify.\n\nThe Uniform Resource Locator, more commonly known as URL, is the address that specifies the location of a file on the Internet. When using allinurl: in your query, do not include any other search operators. The functionality of allinurl: is also available through the Advanced Web Search page, under Occurrences.\n\n## author:\n\nIf you include author: in your query, Google will restrict your Google Groups results to include newsgroup articles by the author you specify. The author can be a full or partial name or email address. For example, [ children author:john author:doe ] or [ children author:doe@someaddress.com ] return articles that contain the word “children” written by John Doe or doe@someaddress.com.\n\nGoogle will search for exactly what you specify. If your query contains [ author:”John Doe” ] (with quotes), Google won’t find articles where the author is specified as “Doe, John.”\n\n## cache:\n\nThe query cache:url will display Google’s cached version of a web page, instead of the current version of the page. For example, [ cache:www.eff.org ] will show Google’s cached version of the Electronic Frontier Foundation home page.\n\nNote: Do not put a space between cache: and the URL (web address).\n\nOn the cached version of a page, Google will highlight terms in your query that appear after the cache: search operator. For example, [ cache:www.pandemonia.com/flying/ fly diary ] will show Google’s cached version of Flight Diary in which Hamish Reid’s documents what’s involved in learning how to fly with the terms “fly” and “diary” highlighted.\n\n## define:\n\nIf you start your query with define:, Google shows definitions from pages on the web for the term that follows. This advanced search operator is useful for finding definitions of words, phrases, and acronyms. For example, [ define: blog ] will show definitions for “Blog” (weB LOG).\n\n## ext:\n\nThis is an undocumented alias for filetype:.\n\n## filetype:\n\nIf you include filetype:suffix in your query, Google will restrict the results to pages whose names end in suffix. For example, [ web page evaluation checklist filetype:pdf ] will return Adobe Acrobat pdf files that match the terms “web,” “page,” “evaluation,” and “checklist.” You can restrict the results to pages whose names end with pdf and doc by using the OR operator, e.g. [ email security filetype:pdf OR filetype:doc ].\n\nWhen you don’t specify a File Format in the Advanced Search Form or the filetype: operator, Google searches a variety of file formats; see the table in File Type Conversion.\n\n## group:\n\nIf you include group: in your query, Google will restrict your Google Groups results to newsgroup articles from certain groups or subareas. For example, [ sleep group:misc.kids.moderated ] will return articles in the group misc.kids.moderated that contain the word “sleep” and [ sleep group:misc.kids ] will return articles in the subarea misc.kids that contain the word “sleep.”\n\n## id:\n\nThis is an undocumented alias for info:.\n\n## inanchor:\n\nIf you include inanchor: in your query, Google will restrict the results to pages containing the query terms you specify in the anchor text or links to the page. For example, [ restaurants inanchor:gourmet ] will return pages in which the anchor text on links to the pages contain the word “gourmet” and the page contains the word “restaurants.”\n\n## info:\n\nThe query info:URL will present some information about the corresponding web page. For instance, [ info:gothotel.com ] will show information about the national hotel directory GotHotel.com home page.\n\nNote: There must be no space between the info: and the web page URL.\n\nThis functionality can also be obtained by typing the web page URL directly into a Google search box.\n\n## insubject:\n\nIf you include insubject: in your query, Google will restrict articles in Google Groups to those that contain the terms you specify in the subject. For example, [ insubject:”falling asleep” ] will return Google Group articles that contain the phrase “falling asleep” in the subject.\n\nEquivalent to intitle:.\n\n## intext:\n\nThe query intext:term restricts results to documents containing term in the text. For instance, [ Hamish Reid intext:pandemonia ] will return documents that mention the word “pandemonia” in the text, and mention the names “Hamish” and “Reid” anywhere in the document (text or not).\n\nNote: There must be no space between the intext: and the following word.\n\nPutting intext: in front of every word in your query is equivalent to putting allintext: at the front of your query, e.g., [ intext:handsome intext:poets ] is the same as [ allintext: handsome poets ].\n\n## intitle:\n\nThe query intitle:term restricts results to documents containing term in the title. For instance, [ flu shot intitle:help ] will return documents that mention the word “help” in their titles, and mention the words “flu” and “shot” anywhere in the document (title or not).\n\nNote: There must be no space between the intitle: and the following word.\n\nPutting intitle: in front of every word in your query is equivalent to putting allintitle: at the front of your query, e.g., [ intitle:google intitle:search ] is the same as [ allintitle: google search ].\n\n## inurl:\n\nIf you include inurl: in your query, Google will restrict the results to documents containing that word in the URL. For instance, [ inurl:print site:www.googleguide.com ] searches for pages on Google Guide in which the URL contains the word “print.” It finds pdf files that are in the directory or folder named “print” on the Google Guide website. The query [ inurl:healthy eating ] will return documents that mention the words “healthy” in their URL, and mention the word “eating” anywhere in the document.\n\nNote: There must be no space between the inurl: and the following word.\n\nPutting inurl: in front of every word in your query is equivalent to putting allinurl: at the front of your query, e.g., [ inurl:healthy inurl:eating ] is the same as [ allinurl: healthy eating ].\n\nIn URLs, words are often run together. They need not be run together when you’re using inurl:.\n\n## link:\n\nThe query link:URL shows pages that point to that URL. For example, to find pages that point to Google Guide’s home page, enter:\n\n[ link:www.googleguide.com ]\n\nNote: According to Google’s documentation, “you cannot combine a link: search with a regular keyword search.”\n\nAlso note that when you combine link: with another advanced operator, Google may not return all the pages that match. The following queries should return lots of results, as you can see if you remove the -site: term in each of these queries.\n\nFind links to the Google home page not on Google’s own site.\n\n[ link:www.google.com -site:google.com ]\n\nFind links to the UK Owners Direct home page not on its own site.\n\n[ link:www.www.ownersdirect.co.uk -site:ownersdirect.co.uk ]\n\n## location:\n\nIf you include location: in your query on Google News, only articles from the location you specify will be returned. For example, [ queen location:canada ] will show articles that match the term “queen” from sites in Canada. Many other country names work; try them and see.\n\nTwo-letter US state abbreviations match individual US states, and two-letter Canadian province abbreviations (like NS for Nova Scotia) also work — although some provinces don’t have many newspapers online, so you may not get many results. Some other two-letter abbreviations — such as UK for the United Kingdom — are also available.\n\n## movie:\n\nIf you include movie: in your query, Google will find movie-related information. For examples, see Google’s Blog.\n\n## related:\n\nThe query related:URL will list web pages that are similar to the web page you specify. For instance, [ related:www.consumerreports.org ] will list web pages that are similar to the Consumer Reports home page.\n\nNote: Don’t include a space between the related: and the web page url.\n\nYou can also find similar pages from the “Similar pages” link on Google’s main results page, and from the similar selector in the Page-Specific Search area of the Advanced Search page. If you expect to search frequently for similar pages, consider installing a GoogleScout browser button, which scouts for similar pages.\n\n## site:\n\nIf you include site: in your query, Google will restrict your search results to the site or domain you specify. For example, [ admissions site:www.lse.ac.uk ] will show admissions information from London School of Economics’ site and [ peace site:gov ] will find pages about peace within the .gov domain. You can specify a domain with or without a period, e.g., either as .gov or gov.\n\nNote: Do not include a space between the “site:” and the domain.\n\nYou can use many of the search operators in conjunction with the basic search operators +, –, OR, and \" \". For example, to find information on Windows security from all sites except microsoft.com, enter:\n\n[ windows security –site:microsoft.com ]\n\nYou can also restrict your results to a site or domain through the domains selector on the Advanced Search page.\n\n## source:\n\nIf you include source: in your query, Google News will restrict your search to articles from the news source with the ID you specify. For example, [ election source:new_york_times ] will return articles with the word “election” that appear in the New York Times.\n\nTo find a news source ID, enter a query that includes a term and the name of the publication you’re seeking. You can also specify the publication name in the “news source” field in the Advanced News Search form. You’ll find the news source ID in the query box, following the source: search operator. For example, let’s say you enter the publication name Ha’aretz in the News Source box, then you click the Google Search button. The results page appears, and its search box contains [ peace source:ha_aretz__subscription_ ]. This means that the news source ID is ha*aretz\\_\\_subscription*. This query will only return articles that include the word “peace” from the Israeli newspaper Ha’aretz.\n"
  },
  {
    "url": "/blog/2015-04/life-is-a-state-of-mind",
    "title": "life is a state of mind",
    "date": "2015-10-25",
    "tags": [
      "life"
    ],
    "content": "\n> The subject of this article you are about to read reveals a crucial secret of your life.\n> It concerns a subject that is liable to make fundamental changes in your outlook on the material world.\n> The content of this article is not just a different approach, or a philosophical thought.\n\n一个人从出生就受到条件的制约，因为人居住的环境完全是物质性的。人在这种外界条件的影响下逐渐长大，所有的想法\n都是在物质世界的基础上形成。我们从外界获得的所有信息来源于我们的 5 种感官(Sensors)，视觉、听觉、嗅觉、味觉、触觉\n形成了我们的世界。人从出生就依赖这五种感官，这是我们感知世界的唯一途径。当超越感官，在思维模型上考察\n一个和以往认识完全不同的世界，这个世界是真是假，who knows and who cares ?\n\n> 人是一个映像(Image)，经历的每一件事都是一个短暂的感觉，宇宙是一个影子(Shadow)。\n\n### 眼睛是如何看到这个世界的？\n\n眼睛看见一个事物是一个逐步的过程，首先光线的光量子从物体射向我们的眼睛，穿过眼角膜，最后在眼睛后面的视网膜聚集。\n光信号转化成电信号，从视神经元传到大脑后部，最终在大脑后部这个几立方厘米的区域形成图像。我们一生中看到的所有事物，\n经历的所有事情都在这个狭小黑暗的区域形成图像。“相由心生”从这个意义上讲佛学和科学是汇合的。当我们说我们看到了东西，\n其实是电信号传送到了大脑后沿的成像区域，也就是大脑接收到了特定的电信号，而大脑是完全隔离光线的，大脑不可能和光线发生\n联系，换句话说光线永远照不到大脑内，大脑只是处理外界光线产生的电信号就形成了我们看到的五彩缤纷的世界。\n\n与视觉类似，其它感官的形成也同样是外界的刺激给大脑反馈的电信号。在我们的一生中，从大脑中起源的一切并不是真实的外界，\n而只是大脑复制的映像，我们误认为大脑中的映像是外界存在的实际物质。\n\n### 大脑中的外部世界\n\n上面的分析指出了一个不可否认的推论，我们在世界或者说宇宙中，看到、摸到、听到，从而觉得是物质的东西，其实只是大脑中的\n电信号。如果外部物质反射的光线被阻断或者光线刺激大脑的电信号被阻断，我们就看不到外部的物质了，显然，我们看见的世界只是\n大脑对电信号的解读。天文望远镜里看到的宇宙星空，不是说那些物体有几百万光年远，其实就在我们的大脑中。当你坐在屋子里看电视，\n你的感觉和身体让你觉得自己在屋子里，其实是屋子和你的身体在你的大脑里，只是你大脑里的一个映像。现在回到我们前面一直提到的\n“外界”这个词，其实外界是我们大脑中的外界，我们根本无法跳出大脑里的世界，既然我们不能到达外面真实的世界，我们又凭什么\n确定外界真实存在？？显然，我们无法确定外界是否存在。我们居住的世界只是大脑里感觉的世界，（a state of our minds）。可以做一个小小的\n思维实验，假设把大脑和身体分离，大脑分离出来继续维持生理机能，在大脑外面连接一个能记录信息的电脑（或者示波器），将电脑记录的数据全部\n转换为电子脉冲刻录到光盘，然后反过来将光盘记录的信息用电脑读出转换成电信号再输入给大脑，你想大脑里会发生什么？\n大脑会读出这些电信号，产生前面看到的，听到的，摸到的等等物体的感觉，过去就被重现了。只要电脑不停地给大脑施加电刺激，这个大脑中虚幻的世界\n就一直持续。我们只是意识（life is a state of minds）,我们很容易被感觉欺骗，认为有一些真实存在的东西，比如梦里的东西？。。\n\n### 梦里的世界\n\n在我们平常的世界，我们能有看到，听到，摸到物体的感觉，在梦里我们也有和真实世界一样的感觉，但是梦里，我们没有手，也没有眼睛，我们怎么来的这种感觉，\n梦里也没有任何可以让我们摸和看的“真实”的物体，认为我们在梦中感到的东西是真实的，本身就是一种错觉。一个人在床上沉睡，梦中自己在一个不同的世界，\n也许在梦中的世界他在上天入地，做着非同寻常的事情，但事实上他就在床上一步也没有离开。如果我们能在梦中平安的生活着，\n只有在梦醒的时候，我们才会意识到是做了一场梦，同样的道理也适用于我们正生活的这个被我们认为真实存在的世界。当我们从一场梦中醒来，没有理由不相信我们\n仍然处在另一个更长的梦中，这都是大脑给我们营造的梦境，这个更长的梦我们叫它真实的世界。我们之所以认为梦是幻境，现在的世界是真的，只是我们的惯性思维。\n我们在地球上的生活可能不是清醒的，我们认为现在是在实际生活着，认为似乎刚刚从梦中醒来。\n\n### 谁是自我\n\n所有的事实和分析都指向一个更重要的问题，如果我们生活的所有情形都只是固有的感知，那我们的大脑是什么？我们的意识是什么？如果意识是由物质组成，就像我们的身体\n是由物质组成一样，那意识本身也只是一个被感知的对象，就像外界的物体一样。如果意识只是感觉，是由视觉和触觉等感官创造的，那么到底是什么接收到了这些感觉？\n是谁看到了，谁触摸到了，闻到了，感觉到了。。？是谁在思考，推断，和感觉到“我是我”？我们这个年代一些重要领域的思考也最终指向了这个问题。\nThe ghost in the machine, the small man in the small man ，“我”在哪里？谁在用我的“意识”？谁意识到了“意识”本身？我们在寻找谁看见了这一切。\n实际上， 形而上存在一个东西能够看到听到，那就是灵魂(Soul)，我们所认为的现实世界，是灵魂看见听见的集合。就像梦中我们的身体和感知的世界不是真实存在的一样，\n我们身处的宇宙也不是真实存在的，也不是物理的实在，唯一真实存在的，是灵魂。事物只是灵魂的感知，物理，化学和生物的法则都指向一个结论---人的存在是幻觉。\n"
  },
  {
    "url": "/blog/2015-04/why-the-night-sky-is-dark",
    "title": "why the night sky is dark",
    "date": "2015-04-09",
    "tags": [
      "life"
    ],
    "content": "\n![](/assets/images/galaxy.jpg)\n\n> 夜空总给我一种神秘的感觉，似乎要告诉我什么，像一位睿智的老者、默默的友人……\n> 当你仰望它时内心有莫名的平静……\n> 宇宙中的问题没有简单与复杂的区分，简单与复杂这些形容词，都掺杂了人的主观情感……\n\n这个生活中司空见惯的现象却蕴涵着深刻的道理(`关于奥伯斯佯谬`)。不动脑子的解释就是：夜晚地球的一面背对着太阳，因为没有阳光照射，所以是黑色的。\n\n其实回答的人连问题都没有理解清楚就开始抢答了，我问的是夜空为什么是黑色的，记住是“夜空”，是那片星空，而不是你下意识说出的地球表面。\n也许你要反驳了，地球将太阳光挡住了一部分，而挡住的那部分视线上的夜空因为没有太阳光照射而呈现黑色。好了，反驳也很简单，考虑一下太阳和地球的体积，\n一个太阳大概能装下 160 万个地球，由于太阳和地球距离很远（一个天文单位），所以太阳的视直径很小，你依然觉得地球挡住了很大一部分太阳光？。\n\n用一下隔离法吧，假设你将太阳这个宇宙中的小不点从宇宙天幕上移开了，再来对自己提问（假设你还在地球上活着）--- 为什么夜空是黑色的？\n\n到这里故事似乎变的有点趣味了，有人解释了，夜空之所以是黑色的是因为那里没有星星（恒星）。这样的回答无法令人满意，宇宙中存在无限多个近均匀分布的恒星，\n我们的视线无论从哪个方向看去都能碰到恒星，类似各向同性的 3K 宇宙微波背景辐射，因而夜空应该到处是明亮的呀。还有人解释说星际空间存在大量的气体和尘埃，\n遥远的星光被尘埃吸收导致光度减弱，因而夜空是黑色的。嗯，这么解释稍微有点靠谱，但是仔细想想也是行不通的，因为宇宙中恒星的总光度是趋于无限大的，\n星际物质吸收那么多能量必然自身也会变热而发光……这些看似有道理的解释却都得出了与事实不相符的结论。\n\n宇宙的基本要素是时间和空间，有时当你闭上双眼，是否会小声猜测这无法形容的黑暗是否就是宇宙诞生之初的场景，于是人类的思维就逆向追寻时间和空间的脚步，\n而宇宙大爆炸理论就是这种思维下的产物。难道“夜空为什么是黑色的”也与大爆炸扯上了联系？细细想来不是扯上了联系而是自然而然的联系……\n\n> 1915 年，斯里弗发现大多数河外星系的光谱线都偏向正常位置向红色端移动，这就是“光谱红移”现象。\n> 根据多普勒效应，光谱红移告诉我们大多数河外星系在远离我们而去。\n> 1926 年，哈勃进一步研究了 30 个河外星系的红移得出了哈勃定律：V=H\\*D 星系正在离开我们向四面八方远去，星系的距离与红移量的大小成正比。  \n> 那些 100 亿光年远的类星体，远离我们的速度甚至达到了 0.8 倍光速。  \n> 红移的大小表征了河外星系远离我们的退行速度。哈勃定律说明星系越远它们的退行速度越高，也就是说我们观测的宇宙正在膨胀！\n\n有了上述的两个重要观测再来分析夜空是黑色的本质，由于我们观测的宇宙在膨胀，那么恒星发出的光会因为红移（光谱线向红色端移动）而使能量减弱，\n星系越远红移越大，导致光线能量越低光度越暗。一些遥远的星系发出的光到达观测者的眼睛时能量已经衰减为零，所以我们观测到的夜空是黑色的。\n\n这时候有人要欢呼了，好像这个问题已经解决了，不然！回顾我们的分析过程是在假设宇宙大爆炸成立的情况下作出的，有人会这么推理，因为夜空是黑色的这一现象\n是不争的事实，而如今几乎所有理论都无法很好的解释这个问题，唯独大爆炸理论能比较圆满的解释它，那么我们是否能作出这种推论：大爆炸理论是正确的。\n\n答案显然不行，这不是天文学上的苛刻，这样解释就陷入了循环论证的逻辑怪圈中。正确的态度是：夜空黑暗现象是宇宙大爆炸留下的蛛丝马迹，或许大爆炸理论是正确的\n，又或许还有另一个更加正确的理论未被人类发现。就好像在解释大尺度空间的引力问题上，相对论是比牛顿力学更正确的理论，但你依然无法说明相对论就是正确的，\n虽然水星近日点反常进动和强引力场光线弯曲等等现象佐证了相对论的引力理论，同样 3K 微波背景辐射等现象也佐证了大爆炸理论，但是要推翻一个论断，只需要一个反例\n就够了。于是很多论断就成了既无法被证明正确，也无法被证明错误，游离在三界之外，成了一连串的哥德尔命题，而哥德尔命题又让人联想起了埃舍尔在房间画的那些奇\n特的图画，那些图画又让人听到了巴赫那动人的管风琴曲，像朱自清闻到荷塘的花香，仿佛听到远处高楼上渺远的歌声。宇宙就这么悠然自得的演奏着自己气势恢宏的交响曲.\n\n当然，站在量子力学那诡异的视角里，“夜空为什么是黑色的”可以这样解析，我们的研究对象是夜空，外在表征是黑色，而人类奇怪于这种黑色与夜空之间的关联，\n便有此一问“为什么？”。因为按照推断夜空不应该是黑色的啊，可以说成是亮白色的或者其他什么颜色的，---- 这又与我们观测的夜空是黑色的不一样？。。如此一来\n，要么是眼睛欺骗了我们，要么是现有的理论有缺陷。\n\n遵循第一条探索，假如是我们的眼睛欺骗了我们。就是作为观测者的人自身的因素导致的特定状况下的结论。这条路走下去就会得出“人择原理”：因为人在研究宇宙，\n所以宇宙的一个重要性质就是允许人能存在，人的存在与物理常数有关。例如只要中子和质子的质量稍稍不同于现在的数值，就将有上百种原子核是不稳定的，也将导致\n分子形成和演化的根基，也就不会有人存在。就如同你要问为什么宇宙年龄大于 100 亿年，根据人择原理，人是碳基生命，碳从恒星内部核反应产生，而恒星中的碳必须\n经过超新星爆发才能弥散到宇宙空间，再来构成行星的原料，上述过程至少要 100 亿年，因此宇宙年龄必须在 100 亿年以上，否则不会有人存在，也就不会有人来提出\n这个问题，哈哈，好唯心的说法啊，我不唯心，也不唯物，既是粒子又是波，简直就让人难以接受，我觉得唯相比较好，一切都是大脑中的一个印象（Image）。\n\n再回到“夜空是黑色的”问题上，可以存在许多有特定外在表现的宇宙 ----平行宇宙，可能在那些宇宙上夜空是红色的，黄色的，蓝色的，但是由于人的存在，\n允许人类来观测和思考宇宙的话，某些平行宇宙就不应该存在（否则就不会有人存在），是人在观测宇宙，所以物理常数和宇宙学参数必须取合适的数值才能演化出人，\n而在这些宇宙参数的取值下，呈现在人面前的宇宙夜空就是黑色的。\n\n遵循第二条探索，认为是现有理论不够完善。在解释大尺度空间的均匀性和宇宙结构方面没有足够深入，就如同黑洞，类星体，暗物质这些神秘的宇宙天体一样，夜空也可\n以被看成一个天体，只是人类的观测能力有限，让这些在未来也许放在小学教科书里的内容在我们的时代却是未解之谜。我们这个时代一些重大的发现，量子宇宙学，\n弦论，虚拟现实，人工智能，都是人类在反观自照：我们从何而来，我们要到哪里去，时间，空间，存在与虚无 永远在人类灵魂深处自觉不自觉的发问……\n\n夜空为什么是黑色的？……我们还是没有弄明白她，就像你永远走不进另一个人的内心，我们都是孤独的，正因为我们都是孤独的，所以我们都不孤独。\n其实不是这个问题需要这么啰嗦，需要这么小题大作，它确认很简单，简单得人们都不屑去理会它，但几百年以来有很多睿智的科学家都思索过它，但都无果而终。\n在如今的社会人们也有去追问这些问题的，只是对物质的强烈追求和追求到手之后内心无比的空虚和失落感，使得他们根本无法靠近这类问题散发出的效应场。  \n思考这些问题是宇宙赋予人类的特权，夜空为什么是黑色的 --- 是宇宙在人类面前掀起的神秘面纱的一角，引领人类的特有的思维去认识空间、时间和存在……\n夜空这位智者又在黑暗中偷偷笑了，也许是和人类它的孩子们玩的一个小游戏吧……就好像爷爷想逗逗他可爱的孙子出了一道算术题，看着孩子认真地做着题目，\n他也会心一笑，然后捋捋胡须睡觉去了……\n"
  }
]